<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Budget Health Report</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      :root {
        --bg: #0f172a; /* slate-900 */
        --panel: #111827; /* gray-900 */
        --card: #1f2937; /* gray-800 */
        --text: #e5e7eb; /* gray-200 */
        --muted: #9ca3af; /* gray-400 */
        --accent: #60a5fa; /* blue-400 */
        --good: #22c55e; /* green-500 */
        --warn: #eab308; /* yellow-500 */
        --bad: #ef4444; /* red-500 */
      }
      body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji'; background: var(--bg); color: var(--text); }
      .container { max-width: 1100px; margin: 0 auto; padding: 20px; }
      .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
      .back { display: inline-block; padding: 8px 12px; background: var(--accent); color: #06142b; border-radius: 6px; text-decoration: none; font-weight: 600; }
      .panel { background: var(--panel); border-radius: 10px; padding: 16px; box-shadow: 0 2px 6px rgba(0,0,0,0.35); margin-bottom: 14px; }
      .grid { display: grid; grid-template-columns: 2fr 1fr; gap: 12px; }
      @media (max-width: 900px) { .grid { grid-template-columns: 1fr; } }
      .section-title { font-size: 16px; font-weight: 700; margin: 0 0 10px 0; color: var(--text); }
      .muted { color: var(--muted); font-size: 12px; }
      /* Chart area */
      .chart-wrap { position: relative; height: 320px; }
      #runway-canvas { width: 100%; height: 100%; display: block; background: #0b1222; border-radius: 8px; }
      .markers-layer { position: absolute; inset: 0; pointer-events: none; }
      .marker { position: absolute; transform: translate(-50%, -50%); pointer-events: auto; cursor: pointer; font-size: 16px; }
      .legend { display: flex; gap: 14px; align-items: center; margin-top: 8px; }
      .legend .swatch { width: 14px; height: 4px; border-radius: 2px; display: inline-block; margin-right: 6px; }
      .badge { display: inline-block; background: #374151; color: var(--muted); padding: 2px 8px; border-radius: 999px; font-size: 12px; }
      /* Upcoming and alerts */
      .list { list-style: none; margin: 0; padding: 0; }
      .item { display: flex; justify-content: space-between; align-items: center; padding: 8px 6px; border-bottom: 1px solid #1f2937; }
      .item:last-child { border-bottom: none; }
      .pill { border-radius: 999px; padding: 2px 8px; font-size: 12px; }
      .pill.warn { background: rgba(234,179,8,0.2); color: #facc15; }
      .pill.good { background: rgba(34,197,94,0.2); color: #86efac; }
      .pill.bad { background: rgba(239,68,68,0.2); color: #fecaca; }
      .alert { padding: 10px; border-radius: 8px; margin-bottom: 8px; background: #0b1222; border: 1px solid #1f2937; }
      .alert.critical { border-color: var(--bad); }
      .alert.warning { border-color: var(--warn); }
      .alert.success { border-color: var(--good); }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1 style="margin:0">üìä Budget Health</h1>
        <a class="back" href="{{ request.url_for('index') }}">‚Üê Back to Chat</a>
      </div>

      <!-- Existing analyzer report remains available below -->
      <div class="panel" role="region" aria-label="Runway chart and upcoming">
        <div class="grid">
          <div>
            <h2 class="section-title" id="lbl-runway">Runway</h2>
            <div class="chart-wrap" aria-labelledby="lbl-runway" aria-live="polite">
              <canvas id="runway-canvas" role="img" aria-label="Runway chart showing forecasted balances with markers"></canvas>
              <div id="markers" class="markers-layer" aria-hidden="false"></div>
            </div>
            <div class="legend" aria-label="Chart legend">
              <span><span class="swatch" style="background:#60a5fa"></span>Baseline</span>
              <span><span class="swatch" style="background:#ef4444"></span>Below buffer</span>
              <span aria-label="Commitment marker">üìÑ Commitment</span>
              <span aria-label="Key event marker">üéÇ Key event</span>
              <span id="legend-meta" class="badge"></span>
            </div>
          </div>
          <div>
            <h2 class="section-title">Upcoming (next 14‚Äì30 days)</h2>
            <ul id="upcoming-list" class="list" role="list" aria-live="polite"></ul>
          </div>
        </div>
      </div>

      <div class="panel" role="region" aria-label="Alerts panel">
        <h2 class="section-title">Alerts</h2>
        <div id="alerts"></div>
      </div>

      <div class="panel">
        <div class="section-title">Detailed Health Report</div>
        <div class="muted" style="margin-bottom:6px">Generated by analyzer</div>
        <div class="content" id="health-report">
          {{ report_html | safe }}
        </div>
      </div>
    </div>

    <script>
      function fmtCents(cents) {
        const sign = cents < 0 ? '-' : '';
        const abs = Math.abs(cents);
        return sign + '$' + (abs/100).toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
      }

      function downsample(points, maxPoints=300) {
        if (points.length <= maxPoints) return points;
        const step = Math.ceil(points.length / maxPoints);
        const out = [];
        for (let i = 0; i < points.length; i += step) out.push(points[i]);
        if (out[out.length-1] !== points[points.length-1]) out.push(points[points.length-1]);
        return out;
      }

      function drawRunway(canvas, series, threshold, markers) {
        const ctx = canvas.getContext('2d');
        const w = canvas.clientWidth, h = canvas.clientHeight;
        canvas.width = w * devicePixelRatio; canvas.height = h * devicePixelRatio;
        ctx.scale(devicePixelRatio, devicePixelRatio);
        ctx.clearRect(0,0,w,h);

        if (series.length === 0) return;
        // Compute min/max
        let minY = Math.min(...series.map(p => p[1]));
        let maxY = Math.max(...series.map(p => p[1]));
        if (threshold !== null && threshold !== undefined) {
          minY = Math.min(minY, threshold);
          maxY = Math.max(maxY, threshold);
        }
        if (minY === maxY) { maxY += 1; minY -= 1; }

        const padL = 30, padR = 10, padT = 16, padB = 24;
        const innerW = w - padL - padR;
        const innerH = h - padT - padB;
        const x0 = series[0][0], x1 = series[series.length-1][0];
        const xRange = x1 - x0 || 1;
        const yRange = maxY - minY || 1;

        const xScale = x => padL + (x - x0) / xRange * innerW;
        const yScale = y => padT + (1 - (y - minY) / yRange) * innerH;

        // Axes grid (light)
        ctx.strokeStyle = '#1f2937'; ctx.lineWidth = 1; ctx.beginPath();
        for (let i = 0; i <= 4; i++) {
          const yy = padT + i * (innerH/4);
          ctx.moveTo(padL, yy); ctx.lineTo(w - padR, yy);
        }
        ctx.stroke();

        // Threshold line
        if (threshold !== null && threshold !== undefined) {
          ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 1.5; ctx.setLineDash([4,4]);
          ctx.beginPath();
          const ty = yScale(threshold);
          ctx.moveTo(padL, ty); ctx.lineTo(w - padR, ty); ctx.stroke();
          ctx.setLineDash([]);
        }

        // Baseline series
        ctx.strokeStyle = '#60a5fa'; ctx.lineWidth = 2.0; ctx.beginPath();
        series.forEach((p, i) => { const x = xScale(p[0]), y = yScale(p[1]); if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); });
        ctx.stroke();

        // Paint areas below threshold lightly
        if (threshold !== null && threshold !== undefined) {
          ctx.fillStyle = 'rgba(239, 68, 68, 0.08)';
          ctx.beginPath();
          let started = false;
          series.forEach((p, i) => {
            if (p[1] < threshold) {
              const x = xScale(p[0]); const y = yScale(p[1]);
              if (!started) { ctx.moveTo(x, yScale(threshold)); started = true; }
              ctx.lineTo(x, y);
            } else if (started) {
              const x = xScale(p[0]); ctx.lineTo(x, yScale(threshold)); started = false;
            }
          });
          if (started) { const x = xScale(series[series.length-1][0]); ctx.lineTo(x, yScale(threshold)); }
          ctx.closePath(); ctx.fill();
        }

        // Position markers layer elements
        const layer = document.getElementById('markers');
        layer.querySelectorAll('.marker').forEach(el => el.remove());
        (markers || []).forEach(m => {
          const el = document.createElement('button');
          el.className = 'marker';
          el.type = 'button';
          el.style.left = xScale(m.x) + 'px';
          el.style.top = yScale(m.y) + 'px';
          el.textContent = m.emoji;
          el.setAttribute('aria-label', m.aria);
          el.setAttribute('title', m.title);
          el.tabIndex = 0;
          el.addEventListener('click', () => {
            // Simple drilldown: announce in legend and focus canvas
            const legend = document.getElementById('legend-meta');
            if (legend) legend.textContent = m.title;
            canvas.focus();
          });
          layer.appendChild(el);
        });
      }

      async function loadUI() {
        try {
          // Load overview for horizon + buffer
          const resOv = await fetch('{{ request.url_for("index") }}api/overview'.replace(/\/$/, ''));
          const ov = await resOv.json();
          const start = ov.horizon?.start; const end = ov.horizon?.end;
          const buffer = ov.buffer_floor_cents ?? 0;

          const url = new URL('{{ request.url_for("index") }}api/forecast/calendar'.replace(/\/$/, ''));
          url.searchParams.set('start', start);
          url.searchParams.set('end', end);
          url.searchParams.set('buffer_floor', String(buffer));
          const resFc = await fetch(url.toString());
          if (!resFc.ok) throw new Error('Failed to load forecast');
          const fc = await resFc.json();

          // Build time series from balances (sorted by date)
          const entries = fc.entries || [];
          const balances = Object.entries(fc.balances || {}).map(([d, b]) => [new Date(d).getTime(), b]).sort((a,b) => a[0]-b[0]);
          const series = downsample(balances);

          // Prepare markers for commitments and key events
          const markers = entries
            .filter(e => e.type === 'commitment' || e.type === 'key_event')
            .map(e => ({
              x: new Date(e.date).getTime(),
              y: (fc.balances || {})[e.date] ?? fc.opening_balance_cents,
              emoji: e.type === 'commitment' ? 'üìÑ' : 'üéÇ',
              title: `${e.type === 'commitment' ? 'Commitment' : 'Key event'} ‚Ä¢ ${e.name} ‚Ä¢ ${e.date} ‚Ä¢ ${fmtCents(e.amount_cents)}`,
              aria: `${e.type === 'commitment' ? 'Commitment' : 'Key event'} ${e.name} on ${e.date}, amount ${fmtCents(e.amount_cents)}`,
              type: e.type,
              name: e.name,
              date: e.date,
              amount_cents: e.amount_cents
            }));

          drawRunway(document.getElementById('runway-canvas'), series, buffer, markers);

          // Upcoming list: commitments within 14 days and key events within 30 days
          const today = new Date(); today.setHours(0,0,0,0);
          const d14 = new Date(today.getTime() + 14*86400000);
          const d30 = new Date(today.getTime() + 30*86400000);
          const upcoming = entries.filter(e => {
            const dt = new Date(e.date);
            if (dt < today) return false;
            if (e.type === 'commitment') return dt <= d14;
            if (e.type === 'key_event') return dt <= d30;
            return false;
          }).map(e => ({...e}));
          // Sort: date asc, then amount abs desc, then name
          upcoming.sort((a,b) => (new Date(a.date)-new Date(b.date)) || (Math.abs(b.amount_cents)-Math.abs(a.amount_cents)) || a.name.localeCompare(b.name));
          const ul = document.getElementById('upcoming-list');
          ul.innerHTML = '';
          upcoming.slice(0, 12).forEach(e => {
            const li = document.createElement('li'); li.className = 'item';
            const left = document.createElement('div');
            left.textContent = `${e.type === 'commitment' ? 'üìÑ' : 'üéÇ'} ${e.name}`;
            const right = document.createElement('div');
            const pill = document.createElement('span');
            const days = Math.round((new Date(e.date) - today)/86400000);
            if (days <= 3) { pill.className = 'pill bad'; pill.textContent = `${days}d`; }
            else if (days <= 7) { pill.className = 'pill warn'; pill.textContent = `${days}d`; }
            else { pill.className = 'pill good'; pill.textContent = `${days}d`; }
            right.innerHTML = `<span class=\"muted\" style=\"margin-right:8px\">${e.date}</span>${fmtCents(e.amount_cents)} `;
            right.appendChild(pill);
            li.appendChild(left); li.appendChild(right); ul.appendChild(li);
          });

          // Alerts: derive deterministically from API values
          const alerts = [];
          const todayBal = (fc.balances || {})[new Date().toISOString().slice(0,10)] ?? fc.opening_balance_cents;
          if (ov.health_band === 'üî¥' || (ov.health_score !== undefined && ov.health_score < 40)) {
            alerts.push({type:'critical', message: 'Low runway ‚Äî health in red', detail: `Health score ${ov.health_score}`});
          }
          // Next cliff from balances vs buffer
          if (buffer > 0) {
            const sorted = Object.keys(fc.balances || {}).sort();
            for (const d of sorted) {
              const bal = fc.balances[d];
              const t = new Date(d);
              t.setHours(0,0,0,0);
              if (t >= today && bal < buffer) { alerts.push({type:'warning', message: `Projected balance below buffer on ${d}`, detail: fmtCents(bal)}); break; }
            }
          }
          // Very low safe-to-spend today
          if ((ov.safe_to_spend_today_cents ?? 0) < Math.max(5000, buffer * 0.1)) {
            alerts.push({type:'warning', message: 'Low safe-to-spend today', detail: fmtCents(ov.safe_to_spend_today_cents)});
          }

          const alertBox = document.getElementById('alerts');
          alertBox.innerHTML = '';
          if (alerts.length === 0) {
            const ok = document.createElement('div'); ok.className = 'alert success'; ok.textContent = 'No alerts at this time.'; alertBox.appendChild(ok);
          } else {
            alerts.forEach(a => {
              const div = document.createElement('div'); div.className = `alert ${a.type}`; div.tabIndex = 0; div.setAttribute('role','button');
              div.innerHTML = `<strong>${a.message}</strong><div class=\"muted\">${a.detail || ''}</div>`;
              div.addEventListener('click', () => {
                // Drilldown: focus chart region
                document.getElementById('runway-canvas').scrollIntoView({behavior:'smooth', block:'center'});
              });
              alertBox.appendChild(div);
            });
          }

          // Legend meta
          const meta = document.getElementById('legend-meta');
          if (meta) meta.textContent = `${start} ‚Üí ${end}`;
        } catch (e) {
          const alertBox = document.getElementById('alerts');
          const div = document.createElement('div'); div.className = 'alert'; div.textContent = 'Unable to load forecast/overview.'; alertBox.appendChild(div);
        }
      }

      // Kick off
      loadUI();
      // Redraw on resize for crisp canvas
      addEventListener('resize', () => {
        const canvas = document.getElementById('runway-canvas');
        // Read last computed data from dataset if stored, otherwise trigger reload
        loadUI();
      });
    </script>
  </body>
  </html>
