<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Budget Health Report</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    {% if csrf_token %}
    <meta name="csrf-token" content="{{ csrf_token }}">
    {% endif %}
    <meta name="currency-symbol" content="{{ currency_symbol or '‚Ç¨' }}">
    <style>
      :root {
        --bg: #0f172a; /* slate-900 */
        --panel: #111827; /* gray-900 */
        --card: #1f2937; /* gray-800 */
        --text: #e5e7eb; /* gray-200 */
        --muted: #9ca3af; /* gray-400 */
        --accent: #60a5fa; /* blue-400 */
        --good: #22c55e; /* green-500 */
        --warn: #eab308; /* yellow-500 */
        --bad: #ef4444; /* red-500 */
      }
      body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji'; background: var(--bg); color: var(--text); }
      .container { max-width: 1100px; margin: 0 auto; padding: 20px; }
      .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
      .back { display: inline-block; padding: 8px 12px; background: var(--accent); color: #06142b; border-radius: 6px; text-decoration: none; font-weight: 600; }
      .panel { background: var(--panel); border-radius: 10px; padding: 16px; box-shadow: 0 2px 6px rgba(0,0,0,0.35); margin-bottom: 14px; }
      .grid { display: grid; grid-template-columns: 2fr 1fr; gap: 12px; }
      @media (max-width: 900px) { .grid { grid-template-columns: 1fr; } }
      .section-title { font-size: 16px; font-weight: 700; margin: 0 0 10px 0; color: var(--text); }
      .muted { color: var(--muted); font-size: 12px; }
      /* Chart area */
      .chart-wrap { position: relative; height: 320px; }
      #runway-canvas { width: 100%; height: 100%; display: block; background: #0b1222; border-radius: 8px; }
      .markers-layer { position: absolute; inset: 0; pointer-events: none; }
      .marker { position: absolute; transform: translate(-50%, -50%); pointer-events: auto; cursor: pointer; font-size: 16px; }
      .legend { display: flex; gap: 14px; align-items: center; margin-top: 8px; }
      .legend .swatch { width: 14px; height: 4px; border-radius: 2px; display: inline-block; margin-right: 6px; }
      .badge { display: inline-block; background: #374151; color: var(--muted); padding: 2px 8px; border-radius: 999px; font-size: 12px; }
      /* Upcoming and alerts */
      .list { list-style: none; margin: 0; padding: 0; }
      .item { display: flex; justify-content: space-between; align-items: center; padding: 8px 6px; border-bottom: 1px solid #1f2937; }
      .item:last-child { border-bottom: none; }
      .pill { border-radius: 999px; padding: 2px 8px; font-size: 12px; }
      .pill.warn { background: rgba(234,179,8,0.2); color: #facc15; }
      .pill.good { background: rgba(34,197,94,0.2); color: #86efac; }
      .pill.bad { background: rgba(239,68,68,0.2); color: #fecaca; }
      .alert { padding: 10px; border-radius: 8px; margin-bottom: 8px; background: #0b1222; border: 1px solid #1f2937; display:flex; justify-content:space-between; align-items:flex-start; gap:10px; }
      .alert.critical { border-color: var(--bad); }
      .alert.warning { border-color: var(--warn); }
      .alert.success { border-color: var(--good); }
      .alert .meta { font-size: 12px; color: var(--muted); }
      .alert .actions { display:flex; gap:6px; }
      .btn-link { background:none; border:none; color:#93c5fd; cursor:pointer; padding:0; font-size:12px; text-decoration:underline; }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1 style="margin:0">üìä Budget Health</h1>
        <div style="display:flex; gap:8px; align-items:center">
          <a id="btn-ical" href="#" download style="display:none; padding:8px 12px; border-radius:6px; background:#3b82f6; color:#06142b; font-weight:600; text-decoration:none">üìÖ Download .ics</a>
          <button id="btn-add-key-event" type="button" style="padding:8px 12px; border-radius:6px; background:#10b981; color:#031b17; font-weight:600; border:none; cursor:pointer">Ôºã Key Event</button>
          <a class="back" href="{{ request.url_for('index') }}">‚Üê Back to Chat</a>
        </div>
      </div>

      <!-- Existing analyzer report remains available below -->
      <div class="panel" role="region" aria-label="Runway chart and upcoming">
        <div class="grid">
          <div>
            <h2 class="section-title" id="lbl-runway">Runway</h2>
            <div style="display:flex; gap:8px; align-items:center; margin-bottom:6px">
              <label class="muted" for="forecast-mode">Mode</label>
              <select id="forecast-mode" style="background:#0b1222; color:var(--text); border:1px solid #374151; border-radius:6px; padding:4px 8px">
                <option value="det">Deterministic</option>
                <option value="blend">Blended</option>
              </select>
              <label class="muted" for="acct-filter" style="margin-left:8px">Account</label>
              <select id="acct-filter" style="background:#0b1222; color:var(--text); border:1px solid #374151; border-radius:6px; padding:4px 8px; min-width: 160px">
                <option value="all" selected>All accounts</option>
              </select>
              <label class="muted" for="forecast-horizon" style="margin-left:8px">Horizon</label>
              <select id="forecast-horizon" style="background:#0b1222; color:var(--text); border:1px solid #374151; border-radius:6px; padding:4px 8px">
                <option value="auto" selected>Auto</option>
                <option value="7">7 days</option>
                <option value="14">14 days</option>
                <option value="30">1 month</option>
                <option value="90">3 months</option>
                <option value="180">6 months</option>
              </select>
              <span id="legend-band" class="badge" style="display:none">Blended band</span>
            </div>
            <div class="chart-wrap" aria-labelledby="lbl-runway" aria-live="polite">
              <canvas id="runway-canvas" role="img" aria-label="Runway chart showing forecasted balances with markers and axes"></canvas>
              <div id="markers" class="markers-layer" aria-hidden="false"></div>
            </div>
            <div class="legend" aria-label="Chart legend">
              <span><span class="swatch" style="background:#60a5fa"></span>Baseline</span>
              <span><span class="swatch" style="background:#ef4444"></span>Below buffer</span>
              <span aria-label="Commitment marker">üìÑ Commitment</span>
              <span aria-label="Key event marker">üéÇ Key event</span>
              <span id="legend-history" style="display:none"><span class="swatch" style="background:#94a3b8"></span>History (60d)</span>
              <span id="legend-empty-note" class="badge" style="display:none">No scheduled items in this horizon. Showing flat baseline.</span>
              <span id="legend-meta" class="badge" aria-live="polite"></span>
            </div>
          </div>
          <div>
            <h2 id="upcoming-title" class="section-title">Upcoming</h2>
            <ul id="upcoming-list" class="list" role="list" aria-live="polite"></ul>
          </div>
        </div>
      </div>

      <div class="panel" role="region" aria-label="Alerts panel">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:8px">
          <h2 class="section-title" style="margin:0">Alerts</h2>
          <div class="muted" style="display:flex; align-items:center; gap:10px">
            <label style="display:flex; align-items:center; gap:6px">
              <input id="toggle-alert-notify" type="checkbox" />
              <span>Browser notifications</span>
            </label>
            <span id="alerts-updated" aria-live="polite"></span>
          </div>
        </div>
        <div id="alerts" role="list" aria-live="polite"></div>
      </div>

      <div class="panel">
        <div class="section-title">Detailed Health Report</div>
        <div class="muted" style="margin-bottom:6px">Generated by analyzer</div>
        <div class="content" id="health-report">
          <div class="panel" role="region" aria-label="Budget health report (embedded)">
            <h2 class="section-title">Budget Health Report</h2>
            <iframe id="bh-report" title="Budget Health Report"
                    srcdoc="{{ report_html | replace('"','&quot;') | safe }}"
                    style="width:100%; border:0; background:#ffffff; border-radius:8px;"
                    loading="lazy"></iframe>
          </div>
        </div>
      </div>
    </div>

    <!-- Key Event Modal -->
    <div id="key-event-modal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.5); align-items:center; justify-content:center;">
      <div role="dialog" aria-modal="true" aria-labelledby="ke-title" style="background:var(--panel); border:1px solid #1f2937; border-radius:10px; width:min(520px, 92vw); padding:16px; box-shadow:0 6px 30px rgba(0,0,0,0.5)">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px">
          <div id="ke-title" class="section-title">Key Event</div>
          <button id="ke-close" type="button" style="background:#111827; color:var(--text); border:1px solid #374151; border-radius:6px; padding:4px 8px; cursor:pointer">‚úï</button>
        </div>
        <form id="ke-form" style="display:grid; grid-template-columns:1fr 1fr; gap:10px">
          <input type="hidden" name="id" />
          <label style="grid-column:1 / -1">Name
            <input name="name" required style="width:100%; padding:8px; border-radius:6px; border:1px solid #374151; background:#0b1222; color:var(--text)" />
          </label>
          <label>Event date
            <input name="event_date" type="date" required style="width:100%; padding:8px; border-radius:6px; border:1px solid #374151; background:#0b1222; color:var(--text)" />
          </label>
          <label>Amount (cents)
            <input name="planned_amount_cents" type="number" step="1" min="0" style="width:100%; padding:8px; border-radius:6px; border:1px solid #374151; background:#0b1222; color:var(--text)" />
          </label>
          <label>Repeat
            <select name="repeat_rule" style="width:100%; padding:8px; border-radius:6px; border:1px solid #374151; background:#0b1222; color:var(--text)">
              <option value="ONE_OFF">One-off</option>
              <option value="ANNUAL">Annual</option>
              <option value="MONTHLY">Monthly</option>
              <option value="WEEKLY">Weekly</option>
            </select>
          </label>
          <label>Lead time (days)
            <input name="lead_time_days" type="number" min="0" step="1" style="width:100%; padding:8px; border-radius:6px; border:1px solid #374151; background:#0b1222; color:var(--text)" />
          </label>
          <label>Shift policy
            <select name="shift_policy" style="width:100%; padding:8px; border-radius:6px; border:1px solid #374151; background:#0b1222; color:var(--text)">
              <option value="AS_SCHEDULED">As scheduled</option>
              <option value="PREV_BUSINESS_DAY">Prev business day</option>
              <option value="NEXT_BUSINESS_DAY">Next business day</option>
            </select>
          </label>
          <label>Account ID
            <input name="account_id" type="number" step="1" min="1" style="width:100%; padding:8px; border-radius:6px; border:1px solid #374151; background:#0b1222; color:var(--text)" />
          </label>
          <label>Category ID
            <input name="category_id" type="number" step="1" min="1" style="width:100%; padding:8px; border-radius:6px; border:1px solid #374151; background:#0b1222; color:var(--text)" />
          </label>
          <div style="grid-column:1 / -1; display:flex; justify-content:flex-end; gap:8px; margin-top:6px">
            <button id="ke-delete" type="button" style="display:none; background:#7f1d1d; color:#fecaca; border:1px solid #ef4444; border-radius:6px; padding:8px 12px; cursor:pointer">Delete</button>
            <button type="submit" style="background:#2563eb; color:white; border:none; border-radius:6px; padding:8px 12px; cursor:pointer">Save</button>
          </div>
          <div id="ke-error" class="muted" style="grid-column:1 / -1; color:#fecaca"></div>
        </form>
      </div>
    </div>

    <script>
      // --- Key Event Modal ---
      const modal = document.getElementById('key-event-modal');
      const openBtn = document.getElementById('btn-add-key-event');
      const closeBtn = document.getElementById('ke-close');
      const form = document.getElementById('ke-form');
      const delBtn = document.getElementById('ke-delete');
      const errBox = document.getElementById('ke-error');

      function openModal(prefill) {
        form.reset(); errBox.textContent='';
        if (prefill && prefill.id) {
          form.elements['id'].value = prefill.id;
          form.elements['name'].value = prefill.name || '';
          form.elements['event_date'].value = prefill.event_date || '';
          form.elements['planned_amount_cents'].value = prefill.planned_amount_cents ?? '';
          form.elements['repeat_rule'].value = prefill.repeat_rule || 'ONE_OFF';
          form.elements['lead_time_days'].value = prefill.lead_time_days ?? '';
          form.elements['shift_policy'].value = prefill.shift_policy || 'AS_SCHEDULED';
          form.elements['account_id'].value = prefill.account_id ?? '';
          form.elements['category_id'].value = prefill.category_id ?? '';
          delBtn.style.display = '';
        } else {
          delBtn.style.display = 'none';
        }
        modal.style.display = 'flex';
      }
      function closeModal() { modal.style.display = 'none'; }
      openBtn?.addEventListener('click', () => openModal());
      closeBtn?.addEventListener('click', closeModal);
      modal?.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });

      function csrfHeader() {
        const meta = document.querySelector('meta[name="csrf-token"]');
        return meta ? { 'X-CSRF-Token': meta.getAttribute('content') } : {};
      }

      function adminHeader() {
        try {
          const tok = localStorage.getItem('adminToken') || localStorage.getItem('admin_token');
          return tok ? { 'X-Admin-Token': tok } : {};
        } catch { return {}; }
      }

      form?.addEventListener('submit', async (e) => {
        e.preventDefault(); errBox.textContent='';
        const data = Object.fromEntries(new FormData(form).entries());
        // Normalize numbers/empties
        if (!data.name || !data.event_date) { errBox.textContent = 'Name and date are required'; return; }
        const payload = {
          id: data.id ? Number(data.id) : undefined,
          name: String(data.name),
          event_date: String(data.event_date),
          repeat_rule: data.repeat_rule || 'ONE_OFF',
          planned_amount_cents: data.planned_amount_cents ? Number(data.planned_amount_cents) : undefined,
          category_id: data.category_id ? Number(data.category_id) : undefined,
          lead_time_days: data.lead_time_days ? Number(data.lead_time_days) : undefined,
          shift_policy: data.shift_policy || 'AS_SCHEDULED',
          account_id: data.account_id ? Number(data.account_id) : undefined,
        };
        try {
          const res = await fetch('{{ request.url_for("index") }}api/key-events'.replace(/\/$/, ''), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', ...csrfHeader(), ...adminHeader() },
            body: JSON.stringify(payload),
          });
          if (!res.ok) {
            const j = await res.json().catch(() => ({}));
            throw new Error(j.detail || 'Error saving event');
          }
          closeModal();
          // Refresh the UI to show effects in forecast
          loadUI();
        } catch (err) {
          errBox.textContent = String(err.message || err);
        }
      });

      delBtn?.addEventListener('click', async () => {
        errBox.textContent='';
        const id = form.elements['id'].value;
        if (!id) { errBox.textContent = 'No ID'; return; }
        if (!confirm('Delete this key event?')) return;
        try {
          const res = await fetch('{{ request.url_for("index") }}api/key-events/'.replace(/\/$/, '') + encodeURIComponent(id), {
            method: 'DELETE',
            headers: { ...csrfHeader(), ...adminHeader() },
          });
          if (!res.ok) {
            const j = await res.json().catch(() => ({}));
            throw new Error(j.detail || 'Error deleting event');
          }
          closeModal();
          loadUI();
        } catch (err) {
          errBox.textContent = String(err.message || err);
        }
      });
    </script>

    <script>
      const CUR = (document.querySelector('meta[name="currency-symbol"]')?.getAttribute('content')) || '‚Ç¨';
      function fmtCents(cents) {
        const sign = cents < 0 ? '-' : '';
        const abs = Math.abs(cents);
        return sign + CUR + (abs/100).toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
      }

      function downsample(points, maxPoints=300) {
        if (points.length <= maxPoints) return points;
        const step = Math.ceil(points.length / maxPoints);
        const out = [];
        for (let i = 0; i < points.length; i += step) out.push(points[i]);
        if (out[out.length-1] !== points[points.length-1]) out.push(points[points.length-1]);
        return out;
      }

      function drawRunway(canvas, series, threshold, markers, band, history) {
        const ctx = canvas.getContext('2d');
        const w = canvas.clientWidth, h = canvas.clientHeight;
        canvas.width = w * devicePixelRatio; canvas.height = h * devicePixelRatio;
        ctx.scale(devicePixelRatio, devicePixelRatio);
        ctx.clearRect(0,0,w,h);

        if ((!series || series.length === 0) && (!history || history.length === 0)) return;
        // Compute min/max
        const allY = [
          ...(series && series.length ? series.map(p => p[1]) : []),
          ...(history && history.length ? history.map(p => p[1]) : []),
        ];
        let minY = Math.min(...allY);
        let maxY = Math.max(...allY);
        if (threshold !== null && threshold !== undefined) {
          minY = Math.min(minY, threshold);
          maxY = Math.max(maxY, threshold);
        }
        if (minY === maxY) { maxY += 1; minY -= 1; }

        const padL = 44, padR = 10, padT = 16, padB = 34;
        const innerW = w - padL - padR;
        const innerH = h - padT - padB;
        const firstX = (arr) => (arr && arr.length ? arr[0][0] : null);
        const lastX = (arr) => (arr && arr.length ? arr[arr.length-1][0] : null);
        const sx0 = firstX(series), sx1 = lastX(series);
        const hx0 = firstX(history), hx1 = lastX(history);
        const x0 = Math.min(...[sx0, hx0].filter(v => v !== null));
        const x1 = Math.max(...[sx1, hx1].filter(v => v !== null));
        const xRange = x1 - x0 || 1;
        const yRange = maxY - minY || 1;

        const xScale = x => padL + (x - x0) / xRange * innerW;
        const yScale = y => padT + (1 - (y - minY) / yRange) * innerH;

        // Axes grid (light)
        ctx.strokeStyle = '#1f2937'; ctx.lineWidth = 1; ctx.beginPath();
        for (let i = 0; i <= 4; i++) {
          const yy = padT + i * (innerH/4);
          ctx.moveTo(padL, yy); ctx.lineTo(w - padR, yy);
        }
        ctx.stroke();

        // Axis labels and ticks (top = max, bottom = min)
        ctx.fillStyle = '#9ca3af';
        ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        for (let i = 0; i <= 4; i++) {
          const yVal = maxY - i * (yRange/4);
          const yy = padT + i * (innerH/4);
          const units = yVal / 100;
          const yAbs = Math.abs(units).toLocaleString(undefined, {maximumFractionDigits: 0});
          const yLabel = units < 0 ? ('-' + CUR + yAbs) : (CUR + yAbs);
          ctx.fillText(yLabel, padL - 6, yy);
        }
        // X labels (dates)
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        for (let i = 0; i <= 4; i++) {
          const xVal = x0 + i * (xRange/4);
          const xx = xScale(xVal);
          const d = new Date(xVal);
          const xLabel = d.toLocaleDateString(undefined, {month:'short', day:'numeric'});
          ctx.fillText(xLabel, xx, h - padB + 8);
        }
        // Draw axis lines
        ctx.strokeStyle = '#1f2937'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(padL, padT); ctx.lineTo(padL, h - padB); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(padL, h - padB); ctx.lineTo(w - padR, h - padB); ctx.stroke();

        // Zero line to aid orientation when range crosses 0
        if (minY < 0 && maxY > 0) {
          const zy = yScale(0);
          ctx.strokeStyle = '#334155'; // slate-700
          ctx.setLineDash([2,2]);
          ctx.beginPath(); ctx.moveTo(padL, zy); ctx.lineTo(w - padR, zy); ctx.stroke();
          ctx.setLineDash([]);
        }

        // Seam between history and forecast (vertical line at forecast start)
        const seamX = (series && series.length) ? series[0][0] : null;
        if (seamX !== null) {
          const xx = xScale(seamX);
          ctx.strokeStyle = '#9ca3af'; // muted
          ctx.lineWidth = 1;
          ctx.setLineDash([2,2]);
          ctx.beginPath(); ctx.moveTo(xx, padT); ctx.lineTo(xx, h - padB); ctx.stroke();
          ctx.setLineDash([]);
        }

        // Draw history series first (muted)
        if (history && history.length > 1) {
          ctx.strokeStyle = '#94a3b8'; // slate-400
          ctx.lineWidth = 1.5; ctx.setLineDash([5,3]);
          ctx.beginPath();
          history.forEach((p, i) => { const x = xScale(p[0]), y = yScale(p[1]); if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); });
          ctx.stroke();
          ctx.setLineDash([]);
          const legH = document.getElementById('legend-history'); if (legH) legH.style.display = '';
        } else {
          const legH = document.getElementById('legend-history'); if (legH) legH.style.display = 'none';
        }

        // Threshold line
        if (threshold !== null && threshold !== undefined) {
          ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 1.5; ctx.setLineDash([4,4]);
          ctx.beginPath();
          const ty = yScale(threshold);
          ctx.moveTo(padL, ty); ctx.lineTo(w - padR, ty); ctx.stroke();
          ctx.setLineDash([]);
        }

        // Optional blended band (upper/lower)
        if (band && band.upper && band.lower && band.upper.length > 1 && band.lower.length > 1) {
          const upper = band.upper;
          const lower = band.lower;
          ctx.fillStyle = 'rgba(96,165,250,0.14)';
          ctx.beginPath();
          // Upper path
          upper.forEach((p, i) => { const x = xScale(p[0]), y = yScale(p[1]); if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); });
          // Lower path reverse
          for (let i = lower.length - 1; i >= 0; i--) { const p = lower[i]; const x = xScale(p[0]), y = yScale(p[1]); ctx.lineTo(x,y); }
          ctx.closePath(); ctx.fill();
        }

        // Baseline series
        ctx.strokeStyle = '#60a5fa'; ctx.lineWidth = 2.0; ctx.beginPath();
        series.forEach((p, i) => { const x = xScale(p[0]), y = yScale(p[1]); if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); });
        ctx.stroke();

        // Paint areas below threshold lightly
        if (threshold !== null && threshold !== undefined) {
          ctx.fillStyle = 'rgba(239, 68, 68, 0.08)';
          ctx.beginPath();
          let started = false;
          series.forEach((p, i) => {
            if (p[1] < threshold) {
              const x = xScale(p[0]); const y = yScale(p[1]);
              if (!started) { ctx.moveTo(x, yScale(threshold)); started = true; }
              ctx.lineTo(x, y);
            } else if (started) {
              const x = xScale(p[0]); ctx.lineTo(x, yScale(threshold)); started = false;
            }
          });
          if (started) { const x = xScale(series[series.length-1][0]); ctx.lineTo(x, yScale(threshold)); }
          ctx.closePath(); ctx.fill();
        }

        // Position markers layer elements
        const layer = document.getElementById('markers');
        layer.querySelectorAll('.marker').forEach(el => el.remove());
        (markers || []).forEach(m => {
          const el = document.createElement('button');
          el.className = 'marker';
          el.type = 'button';
          el.style.left = xScale(m.x) + 'px';
          el.style.top = yScale(m.y) + 'px';
          el.textContent = m.emoji;
          el.setAttribute('aria-label', m.aria);
          el.setAttribute('title', m.title);
          el.tabIndex = 0;
          el.addEventListener('click', () => {
            // Simple drilldown: announce in legend and focus canvas
            const legend = document.getElementById('legend-meta');
            if (legend) legend.textContent = m.title;
            canvas.focus();
          });
          layer.appendChild(el);
        });
      }

      let pollTimer = null;
      const SEEN_KEY = 'bb_alert_keys_seen';
      const DISMISSED_KEY = 'bb_alert_keys_dismissed_session';
      const NOTIFY_KEY = 'bb_alert_notify_enabled';

      function getSet(key) {
        try { const j = JSON.parse(localStorage.getItem(key) || '[]'); return new Set(Array.isArray(j)?j:[]); } catch { return new Set(); }
      }
      function setSet(key, set) {
        try { localStorage.setItem(key, JSON.stringify(Array.from(set))); } catch {}
      }
      function getSessSet(key) {
        try { const j = JSON.parse(sessionStorage.getItem(key) || '[]'); return new Set(Array.isArray(j)?j:[]); } catch { return new Set(); }
      }
      function setSessSet(key, set) {
        try { sessionStorage.setItem(key, JSON.stringify(Array.from(set))); } catch {}
      }

      function alertKey(a) { return `${a.type}|${a.message}|${a.detail||''}`; }

      function maybeNotify(newAlerts) {
        const enabled = localStorage.getItem(NOTIFY_KEY) === '1';
        if (!enabled || !('Notification' in window)) return;
        if (Notification.permission === 'default') return; // only notify after explicit grant/deny handled
        if (Notification.permission !== 'granted') return;
        // Limit to first 3 to avoid spam
        newAlerts.slice(0,3).forEach(a => {
          try { new Notification(a.message, { body: a.detail || 'New alert', tag: alertKey(a) }); } catch {}
        });
      }

      function renderAlerts(alerts, asOfISO) {
        const alertBox = document.getElementById('alerts');
        const updated = document.getElementById('alerts-updated');
        if (updated) updated.textContent = asOfISO ? `Updated ${asOfISO.replace('T',' ').replace('Z',' UTC')}` : '';
        alertBox.innerHTML = '';
        if (alerts.length === 0) {
          const ok = document.createElement('div'); ok.className = 'alert success'; ok.setAttribute('role','listitem'); ok.innerHTML = '<div>No alerts at this time.</div>';
          alertBox.appendChild(ok);
          return;
        }
        const dismissed = getSessSet(DISMISSED_KEY);
        alerts.forEach(a => {
          const key = alertKey(a);
          if (dismissed.has(key)) return;
          const div = document.createElement('div'); div.className = `alert ${a.type}`; div.tabIndex = 0; div.setAttribute('role','listitem');
          const left = document.createElement('div');
          left.innerHTML = `<strong>${a.message}</strong><div class="meta">${a.detail || ''}${asOfISO ? ` ‚Ä¢ ${asOfISO}` : ''}</div>`;
          const actions = document.createElement('div'); actions.className = 'actions';
          const btnGo = document.createElement('button'); btnGo.className = 'btn-link'; btnGo.type = 'button'; btnGo.textContent = 'View';
          btnGo.addEventListener('click', () => { document.getElementById('runway-canvas').scrollIntoView({behavior:'smooth', block:'center'}); });
          const btnDismiss = document.createElement('button'); btnDismiss.className = 'btn-link'; btnDismiss.type = 'button'; btnDismiss.textContent = 'Dismiss';
          btnDismiss.addEventListener('click', () => { dismissed.add(key); setSessSet(DISMISSED_KEY, dismissed); div.remove(); });
          actions.appendChild(btnGo); actions.appendChild(btnDismiss);
          div.appendChild(left); div.appendChild(actions);
          alertBox.appendChild(div);
        });
      }

      async function loadUI(_fromPoll=false) {
        try {
          // Populate accounts once
          try {
            const sel = document.getElementById('acct-filter');
            if (sel && sel.options.length === 1) {
              const r = await fetch('{{ request.url_for("index") }}api/accounts'.replace(/\/$/, ''));
              if (r.ok) {
                const j = await r.json();
                const saved = localStorage.getItem('acct_filter') || 'all';
                (j.accounts || []).forEach(acc => {
                  const opt = document.createElement('option');
                  opt.value = String(acc.id);
                  opt.textContent = acc.name;
                  sel.appendChild(opt);
                });
                // Restore selection
                if ([...sel.options].some(o => o.value === saved)) sel.value = saved;
                sel.addEventListener('change', () => {
                  localStorage.setItem('acct_filter', sel.value);
                  loadUI();
                });
              }
            }
          } catch {}

          // Load overview for horizon + buffer
          const resOv = await fetch('{{ request.url_for("index") }}api/overview'.replace(/\/$/, ''));
          const ov = await resOv.json();
          let start = ov.horizon?.start; let end = ov.horizon?.end;
          const buffer = ov.buffer_floor_cents ?? 0;
          const asOfISO = (ov.snapshot?.created_at) || new Date().toISOString();

          // Apply client-selected horizon override if chosen
          try {
            const hSel = document.getElementById('forecast-horizon');
            const val = hSel?.value || 'auto';
            if (val !== 'auto') {
              const days = parseInt(val, 10);
              const today = new Date(); today.setHours(0,0,0,0);
              const to = new Date(today.getTime() + days*86400000);
              const iso = d => new Date(d.getTime()-d.getTimezoneOffset()*60000).toISOString().slice(0,10);
              start = iso(today);
              end = iso(to);
            }
          } catch {}

          // Update iCal export link to match active horizon
          try {
            const ical = document.getElementById('btn-ical');
            if (ical && start && end) {
              const icalUrl = new URL('{{ request.url_for("index") }}api/calendar/ical'.replace(/\/$/, ''));
              icalUrl.searchParams.set('from', start);
              icalUrl.searchParams.set('to', end);
              ical.setAttribute('href', icalUrl.toString());
              ical.style.display = '';
            }
          } catch {}

          const url = new URL('{{ request.url_for("index") }}api/forecast/calendar'.replace(/\/$/, ''));
          url.searchParams.set('start', start);
          url.searchParams.set('end', end);
          url.searchParams.set('buffer_floor', String(buffer));
          try {
            const sel = document.getElementById('acct-filter');
            const v = sel?.value || 'all';
            if (v !== 'all') url.searchParams.set('accounts', v);
          } catch {}
          const resFc = await fetch(url.toString());
          if (!resFc.ok) throw new Error('Failed to load forecast');
          const fc = await resFc.json();

          // Build time series from balances (sorted by date)
          const entries = fc.entries || [];
          const balances = Object.entries(fc.balances || {}).map(([d, b]) => [new Date(d).getTime(), b]).sort((a,b) => a[0]-b[0]);
          const modeEl = document.getElementById('forecast-mode');
          const mode = (modeEl?.value || 'det');
          let series = downsample(balances);
          let band = null;
          let usedFallback = false;
          if (mode === 'blend') {
            const sel = document.getElementById('acct-filter');
            const acctVal = sel?.value || 'all';
            if (acctVal !== 'all') {
              // Disable blended band when filtering by a single account (not yet supported)
              document.getElementById('legend-band').style.display = 'none';
            } else {
            const urlB = new URL('{{ request.url_for("index") }}api/forecast/blended'.replace(/\/$/, ''));
            urlB.searchParams.set('start', start);
            urlB.searchParams.set('end', end);
            const resB = await fetch(urlB.toString());
            if (resB.ok) {
              const bj = await resB.json();
              const blend = bj.baseline_blended || {};
              series = downsample(Object.entries(blend).sort().map(([d,v]) => [new Date(d).getTime(), v]));
              const lower = Object.entries((bj.bands||{}).lower || {}).sort().map(([d,v]) => [new Date(d).getTime(), v]);
              const upper = Object.entries((bj.bands||{}).upper || {}).sort().map(([d,v]) => [new Date(d).getTime(), v]);
              band = { lower: downsample(lower), upper: downsample(upper) };
              document.getElementById('legend-band').style.display = '';
            } else {
              document.getElementById('legend-band').style.display = 'none';
            }
            }
          } else {
            document.getElementById('legend-band').style.display = 'none';
          }

          // Fallback: if no balances in horizon, synthesize flat baseline using opening balance
          if ((!series || series.length === 0) && start && end) {
            const open = fc.opening_balance_cents ?? 0;
            series = [
              [new Date(start).getTime(), open],
              [new Date(end).getTime(), open],
            ];
            usedFallback = true;
          }

          // Prepare markers for commitments and key events
          const markers = entries
            .filter(e => e.type === 'commitment' || e.type === 'key_event')
            .map(e => ({
              x: new Date(e.date).getTime(),
              y: (fc.balances || {})[e.date] ?? fc.opening_balance_cents,
              emoji: e.ui_marker || (e.type === 'commitment' ? 'üìÑ' : 'üéÇ'),
              title: `${e.type === 'commitment' ? 'Commitment' : 'Key event'} ‚Ä¢ ${e.name} ‚Ä¢ ${e.date} ‚Ä¢ ${fmtCents(e.amount_cents)}`,
              aria: `${e.type === 'commitment' ? 'Commitment' : 'Key event'} ${e.name} on ${e.date}, amount ${fmtCents(e.amount_cents)}`,
              type: e.type,
              name: e.name,
              date: e.date,
              amount_cents: e.amount_cents
            }));

          // Load last 60 days history to provide recent trend
          let histSeries = [];
          try {
            if (start) {
              const startDate = new Date(start);
              const histEnd = new Date(startDate.getTime() - 1*86400000);
              const histStart = new Date(startDate.getTime() - 60*86400000);
              const iso = d => new Date(d.getTime()-d.getTimezoneOffset()*60000).toISOString().slice(0,10);
              const urlH = new URL('{{ request.url_for("index") }}api/forecast/history'.replace(/\/$/, ''));
              urlH.searchParams.set('start', iso(histStart));
              urlH.searchParams.set('end', iso(histEnd));
              try {
                const sel = document.getElementById('acct-filter');
                const v = sel?.value || 'all';
                if (v !== 'all') urlH.searchParams.set('accounts', v);
              } catch {}
              const resH = await fetch(urlH.toString());
              if (resH.ok) {
                const fh = await resH.json();
                const hbal = Object.entries(fh.balances || {}).map(([d, b]) => [new Date(d).getTime(), b]).sort((a,b) => a[0]-b[0]);
                histSeries = downsample(hbal);
                if ((!histSeries || histSeries.length === 0) && fh.opening_balance_cents !== undefined) {
                  // Synthesize flat history at opening balance when no entries
                  histSeries = [
                    [histStart.getTime(), fh.opening_balance_cents],
                    [histEnd.getTime(), fh.opening_balance_cents],
                  ];
                }
              }
            }
          } catch {}

          drawRunway(document.getElementById('runway-canvas'), series, buffer, markers, band, histSeries);

          // Upcoming list: commitments within 14 days; key events within lead window
          const today = new Date(); today.setHours(0,0,0,0);
          const d14 = new Date(today.getTime() + 14*86400000);
          const upcoming = entries.filter(e => {
            const dt = new Date(e.date);
            if (dt < today) return false;
            if (e.type === 'commitment') return dt <= d14;
            if (e.type === 'key_event') return e.is_within_lead_window === true;
            return false;
          }).map(e => ({...e}));
          // Sort: date asc, then amount abs desc, then name
          upcoming.sort((a,b) => (new Date(a.date)-new Date(b.date)) || (Math.abs(b.amount_cents)-Math.abs(a.amount_cents)) || a.name.localeCompare(b.name));
          const ul = document.getElementById('upcoming-list');
          ul.innerHTML = '';
          upcoming.slice(0, 12).forEach(e => {
            const li = document.createElement('li'); li.className = 'item';
            const left = document.createElement('div');
            left.textContent = `${e.ui_marker || (e.type === 'commitment' ? 'üìÑ' : 'üéÇ')} ${e.name}`;
            const right = document.createElement('div');
            const pill = document.createElement('span');
            const days = Math.round((new Date(e.date) - today)/86400000);
            if (days <= 3) { pill.className = 'pill bad'; pill.textContent = `${days}d`; }
            else if (days <= 7) { pill.className = 'pill warn'; pill.textContent = `${days}d`; }
            else { pill.className = 'pill good'; pill.textContent = `${days}d`; }
            right.innerHTML = `<span class=\"muted\" style=\"margin-right:8px\">${e.date}</span>${fmtCents(e.amount_cents)} `;
            right.appendChild(pill);
            li.appendChild(left); li.appendChild(right); ul.appendChild(li);
          });

          // Alerts: derive deterministically from API values
          const alerts = [];
          const todayBal = (fc.balances || {})[new Date().toISOString().slice(0,10)] ?? fc.opening_balance_cents;
          if (ov.health_band === 'üî¥' || (ov.health_score !== undefined && ov.health_score < 40)) {
            alerts.push({type:'critical', message: 'Low runway ‚Äî health in red', detail: `Health score ${ov.health_score}`});
          }
          // Next cliff from balances vs buffer
          if (buffer > 0) {
            const sorted = Object.keys(fc.balances || {}).sort();
            for (const d of sorted) {
              const bal = fc.balances[d];
              const t = new Date(d);
              t.setHours(0,0,0,0);
              if (t >= today && bal < buffer) { alerts.push({type:'warning', message: `Projected balance below buffer on ${d}`, detail: fmtCents(bal)}); break; }
            }
          }
          // Very low safe-to-spend today
          if ((ov.safe_to_spend_today_cents ?? 0) < Math.max(5000, buffer * 0.1)) {
            alerts.push({type:'warning', message: 'Low safe-to-spend today', detail: fmtCents(ov.safe_to_spend_today_cents)});
          }

          // Newest first: treat alerts from this fetch as newest; stable order within batch
          const seen = getSet(SEEN_KEY);
          const keys = alerts.map(alertKey);
          const newAlerts = alerts.filter(a => !seen.has(alertKey(a)));
          // Render
          renderAlerts(alerts, asOfISO);
          // Notify on new alerts (from poll or first load) if enabled
          if (newAlerts.length > 0) maybeNotify(newAlerts);
          // Update seen keys
          newAlerts.forEach(a => seen.add(alertKey(a)));
          setSet(SEEN_KEY, seen);

          // Legend meta and empty-series hint
          const meta = document.getElementById('legend-meta');
          if (meta) meta.textContent = `${start} ‚Üí ${end}`;
          const upTitle = document.getElementById('upcoming-title');
          if (upTitle) upTitle.textContent = 'Upcoming (next 14 days)';
          const note = document.getElementById('legend-empty-note');
          if (note) note.style.display = usedFallback ? '' : 'none';
        } catch (e) {
          const alertBox = document.getElementById('alerts');
          const div = document.createElement('div'); div.className = 'alert'; div.textContent = 'Unable to load forecast/overview.'; alertBox.appendChild(div);
        }
      }

      // Notifications toggle wiring
      const notifyToggle = document.getElementById('toggle-alert-notify');
      if (notifyToggle) {
        const enabled = localStorage.getItem(NOTIFY_KEY) === '1';
        notifyToggle.checked = enabled;
        notifyToggle.addEventListener('change', async (e) => {
          const on = notifyToggle.checked;
          if (on && 'Notification' in window) {
            if (Notification.permission === 'default') {
              try { await Notification.requestPermission(); } catch {}
            }
          }
          localStorage.setItem(NOTIFY_KEY, on ? '1' : '0');
        });
      }

      // Kick off and start polling for updates
      loadUI();
      if (pollTimer) clearInterval(pollTimer);
      pollTimer = setInterval(() => { loadUI(true); }, 30000);
      // Redraw on resize for crisp canvas
      addEventListener('resize', () => {
        const canvas = document.getElementById('runway-canvas');
        // Read last computed data from dataset if stored, otherwise trigger reload
        loadUI();
      });
      document.getElementById('forecast-mode')?.addEventListener('change', () => loadUI());
      document.getElementById('forecast-horizon')?.addEventListener('change', () => loadUI());

      // Resize embedded report iframe to its content height
      const rep = document.getElementById('bh-report');
      function sizeReport() {
        try {
          if (!rep?.contentWindow?.document?.body) return;
          const h = rep.contentWindow.document.body.scrollHeight || 0;
          if (h > 0) rep.style.height = (h + 16) + 'px';
        } catch {}
      }
      rep?.addEventListener('load', sizeReport);
      // Attempt sizing after a delay in case fonts load late
      setTimeout(sizeReport, 300);
    </script>
  </body>
  </html>
